## 异常

### 1. C语言传统的处理错误的方式

传统的错误处理机制：

1. 终止程序。如 assert，缺陷就是用户难以接受。如发生内存错误，除0错误就会终止程序。
2. 返回错误码。缺陷是需要管理员自己去查找对应的错误。如系统的很多的接口函数都是通过把错误码放到 errno 中，表示错误。
3. C 标准库中 setjmp 和 longjmp 组合。但不常用。

实际中 C 语言基本都是使用返回错误码的方式处理错误，部分情况下使用终止程序处理非常严重的错误。



### 2. C++ 异常概念

异常是一种处理错误的方式，当一个函数发现自己无法处理的错误时就会抛出异常，让函数的直接或间接的调用者处理这个错误。

* `throw`：当问题出现时，程序会抛出一个异常。通过使用`throw`关键字来完成。
* `catch`：在您想要护理问题的地方，通过异常处理程序捕获异常。`catch`关键字用来捕获异常，可以使用多个`catch`进行捕获。
* `try`：`try`块中的代码表示将被激活的特定异常，后面通常跟着一个或者多个`catch`块。

**try / catch 语法**

~~~c++
try
{
 // 保护的标识代码
}catch( ExceptionName e1 )
{
 // catch 块
}catch( ExceptionName e2 )
{
 // catch 块
}catch( ExceptionName eN )
{
 // catch 块
}
~~~



### 3. 异常的使用

#### 3.1 异常的抛出和捕获

**异常的抛出和匹配原则**

1. 异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。
2. 被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个。
3. 抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成
  一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁。（这里的处理类似于函数的传值返回）
4. catch(...)可以捕获任意类型的异常，问题是不知道异常错误是什么。
5. 实际中抛出和捕获的匹配原则有个例外，并不都是类型完全匹配，可以抛出的派生类对象，使用基类捕
  获。

~~~c++
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;

double division(int a, int b)
{
	//当b = 0 时，抛出异常。
	if (b == 0)
	{
		throw "Division by zero condition."; //抛出异常，类型为char* 
		
		// 此处errmsg是一个临时变量，出了作用域就会被销毁。	 
		// 所以此处抛出的是errmsg的临时拷贝，将此处拷贝赋值给catch中的对象。
		/*string errmsg("Division By Zero Condition.");
		throw errmsg;*/
	}
	else
	{
		return ((double)a / (double)b);

	}
}

void fun()
{
	//捕获异常
	try
	{
		int len, time;
		cin >> len >> time;
		cout << division(len, time) << endl;
	}
	// 此处有catch，但是类型与抛出异常类型不匹配，所以不会被捕获。
	catch(int a) 
	{
		cout << a << endl;
	}

	// 当异常抛出时，会优先匹配类型匹配且离抛出异常位置最近的。
	// 所以当该处捕获与main函数中的捕获同时存在时，会执行此处catch。
	/*catch (const char* errmsg)
	{
		cout << errmsg << endl;
	}*/
	
}


int main()
{
	//捕获异常
	try 
	{
		fun();
	}

	catch (const char* errmsg) // char* 与抛出异常类型匹配，被激活。
	{ 
		cout << errmsg << endl;
	}

	catch (const string& errmsg) // string 
	{
		cout << errmsg << endl;
	}

	// catch(...)捕获任意类型的异常，缺点是不知道异常错误是什么。
	catch (...)
	{
		cout << "未知异常" << endl;
	}
    
	system("pause");
	return 0;
}
~~~



**在函数调用链中异常栈展开匹配原则**

1. 首先检查`throw`本身是否在`try`块内部，如果是再查找匹配的`catch`语句。如果有匹配的，则调到`catch`的地方进行处理。
2. 没有匹配的`catch`则退出当前函数栈，继续在调用函数的栈中进行查找匹配的`catch`。
3. 如果到达`main`函数的栈，依旧没有匹配的，则终止程序。上述这个沿着调用链查找匹配的`catch`子句的过程称为栈展开。所以实际中我们最后都要加一个`catch(...)`捕获任意类型的异常，否则当有异常没捕获，程序就会直接终止。
4. 找到匹配的`catch`子句并处理以后，会继续沿着`catch`子句后面继续执行。

![栈展开匹配原则](https://github.com/Alex-LXF/picture/blob/master/%E5%BC%82%E5%B8%B8/%E6%A0%88%E5%B1%95%E5%BC%80%E5%8E%9F%E5%88%99.png?raw=true)

#### 3.2 异常的重新抛出

有可能单个的catch不能完全处理一个异常，在进行一些校正处理以后，希望再交给更外层的调用链函数来处
理，catch则可以通过重新抛出将异常传递给更上层的函数进行处理。

比如说，你舍友回宿舍没带钥匙，给你打电话问你是否拿钥匙了。此时，你也没拿，你给另外个舍友打电话让看他是否带钥匙，带了将钥匙带回去。

~~~C++
void Func()
{
 // 这里可以看到如果发生除0错误抛出异常，另外下面的array没有得到释放。
 // 所以这里捕获异常后并不处理异常，异常还是交给外面处理，这里捕获了再
 // 重新抛出去。
 int* array = new int[10];
 try {
     int len, time;
     cin >> len >> time;
     cout << division(len, time) << endl;
 }
 catch (...) //不需要知道异常的具体类型，只是为了去释放空间。
 {
     cout << "delete []" << array << endl;
     delete[] array;
     throw; //重新抛出异常，让其他catch在重新捕获。
 }
    
 // ...
 cout << "delete []" << array << endl;

 delete[] array;
}

~~~

#### 3.3 异常安全

* 构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有
  完全初始化；
* 析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句
  柄未关闭等）；
* C++中异常经常会导致资源泄漏的问题，比如在`new`和`delete`中抛出了异常，导致内存泄漏，在`lock`和`unlock`之间抛出了异常导致死锁，C++ 经常使用 RAII 来解决以上问题。

#### 3.4 异常规范

1. 异常规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些。 可以在函数的后面接
  throw(类型)，列出这个函数可能抛掷的所有异常类型。
2. 函数的后面接throw()，表示函数不抛异常。
3. 若无异常接口声明，则此函数可以抛掷任何类型的异常。

~~~C++
// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常
void fun() throw(A，B，C，D);
// 这里表示这个函数只会抛出bad_alloc的异常
void* operator new (std::size_t size) throw (std::bad_alloc);
// 这里表示这个函数不会抛出异常
void* operator new (std::size_t size, void* ptr) throw();
~~~



### 4. 异常的优缺点

**C++异常的优点**

1. 异常对象定义好了，相比错误码的方式可以清晰准确的展示出错误的各种信息，甚至可以包含堆栈调用
  的信息，这样可以帮助更好的定位程序的bug。

2. 返回错误码的传统方式有个很大的问题就是，在函数调用链中，深层的函数返回了错误，那么我们得层
  层返回错误，最外层才能拿到错误。如下：

  ~~~c++
  // 1.下面这段伪代码我们可以看到ConnnectSql中出错了，先返回给ServerStart，ServerStart再返回
  给main函数，main函数再针对问题处理具体的错误。
  // 2.如果是异常体系，不管是ConnnectSql还是ServerStart及调用函数出错，都不用检查，因为抛出的
  异常异常会直接跳到main函数中catch捕获的地方，main函数直接处理错误。
  int ConnnectSql()
  {
       // 用户名密码错误
       if (...)
       	return 1;
       // 权限不足
       if (...)
       	return 2;
  }
  int ServerStart() {
       if (int ret = ConnnectSql() < 0)
           return ret;
       int fd = socket()
       if（fd < 0）
       	return errno;
  }
  int main()
  {
       if(ServerStart()<0)
       ...
       return 0;
  }
  ~~~

3. 很多的第三方库都包含异常，比如boost、gtest、gmock等等常用的库，那么我们使用它们也需要使用
  异常。

4. 很多测试框架都使用异常，这样能更好的使用单元测试等进行白盒的测试。

5. 部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理。比如`T&operator`这样的函数，如果pos越界了只能使用异常或者终止程序处理，没办法通过返回值表示错误。

**C++异常的缺点**

1. 异常会导致程序的执行流乱跳，并且非常的混乱，并且是运行时出错抛异常就会乱跳。这会导致我们跟
  踪调试时以及分析程序时，比较困难。
2. 异常会有一些性能的开销。当然在现代硬件速度很快的情况下，这个影响基本忽略不计。
3. C++没有垃圾回收机制，资源需要自己管理。有了异常非常容易导致内存泄漏、死锁等异常安全问题。
  这个需要使用RAII来处理资源的管理问题。学习成本较高。
4. C++标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱。
5. 异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func() throw();的方式规范化。

**说明**：异常的总体利大于弊，且面向对象语言基本都使用异常处理错误。