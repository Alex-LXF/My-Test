## 多态

### 一、多态的概念

**多态**：多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。通俗来说，同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

比如，我们去旅游景点旅游。如果是成年人，需要支付全部票价。但是如果是学生，就享有半价购票的优惠。对于同一个行为——买票，因为对象不同，所产生的结果也不同，这就是多态。

同样，如果有两支军队，当在战场上听到同种号声。由于事先约定不同，A 军队可能实施进攻，而 B 军队可能准备撤退。

又如在 windows 环境下，用鼠标双击一个对象（这就是向对象传递一个消息），如果对象是一个可执行文件，则会执行此程序，如果对象是一个文本文件，由会启动文本编辑器并打开该文件。

### 二、多态的定义及实现

#### 1、多态的构成条件

多态性可按照发生的时间段分为静多态（Static Polymorphism）和动多态（Dynamic Polymorphism）。其中静多态就是绑定发生在编译期（compile-time），此种绑定称为静态绑定static-binding）；而动多态就是绑定发生在运行期（run-time），此种绑定称为动态绑定（dynamic-binding）。

##### 1.1、静多态构成条件

静多态可以通过模板和函数重载来实现，具体可以分为：
  * 非参数化多态(Ad-hoc polymorphism，特别多态）：
       (a）函数重载（Function Overloading）
       (b）运算符重载（Operator Overloading）
  * 参数化多态（Parametric polymorphism）
       (c）模板（Template）

##### 1.2、动多态构成条件

动多态是通过继承、虚函数或者引用来实现的。动多态的前提必须是继承。

在继承中要构成多态有以下两个条件：

* 调用函数的对象必须是指针或者引用。
* 被调用的函数必须是虚函数，且完成了虚函数的重写。

我们以买票行为举例：

~~~c++
//基类
class Person
{
 public:
    virtual void BuyTicket() // 关键字：virtual + 函数 = 虚函数
    {
        cout << "Person: " <<"买全价票" << endl;
    }
};
//派生类
class Student : public Person
{
 public:
    //对虚函数BuyTicket()的重写
    virtual void BuyTicket() //此处建议加上virtual 
    {
    	cout << "Student: " << "买半价票" << endl;
    }
};

int main()
{
    Person* Jack = new Person; // 创建一个Person对象，类型为Person*
    Jack->BuyTicket(); // 输出结果：Person: 买全价票
    
    Person* Mike = new Student; //创建一个Student对象，类型为Person*
    Mike->BuyTicket(); // 输出结果: Student: 买半价票
    
    return 0;
}
~~~

动多态在C++中是通过虚函数实现的，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。

##### 1.3、虚函数

所谓的虚函数，就是在类的成员函数前加上`virtual`关键字。

~~~C++ 
class Person
{
 public:
 	virtual void BuyTicket()
 	{
        cout << "Person: " << "全价票" << endl;
 	}
};
~~~

* **虚函数的重写**

虚函数的重写：派生类中有一个跟基类的完全相同虚函数，我们就称子类的虚函数重写了基类的虚函数，完
全相同是指：函数名、参数、返回值都相同。另外虚函数的重写也叫作虚函数的覆盖。

* **虚函数重写的例外 ——协变**

虚函数重写有一个例外：重写的虚函数的返回值可以不同，但是必须分别是基类指针和派生类指针或者基类
引用和派生类引用。

~~~C++
// A:基类  B:派生类
class A{};
class B : public A {};

// Person:基类  Student:派生类 
class Person 
{
public:
    virtual A* f() //返回值类型为 A* 基类指针
    {
     	return new A;
 	}
};

class Student : public Person 
{
public:
    virtual B* f()  //返回值为 B* 派生类指针
    {
        return new B;
    }
};

~~~

* **不规范的重写行为**

在派生类中重写的成员函数可以不加`virtual`关键字，也是构成重写的，因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性，我们只是重写了它。但是这是非常不规范的，我们平时不要这样使用。

~~~C++
class Person 
{
public:
    virtual void BuyTicket() //无论何时基类必须含有 virtual 
    {
        cout << "买票-全价" << endl;
    }
};
class Student : public Person 
{
public:
	void BuyTicket()
	{
		cout << "买票-半价" << endl;
	}
};

~~~

* **析构函数的重写问题**

基类中的析构函数如果是虚函数，那么派生类中析构函数就重写了基类的析构函数。它们的函数名不同，按照重写的定义来说，它们违背了重写的规则。但事实上，编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成`destructor`，这也说明的基类的析构函数最好写成虚函数。

~~~C++
class Person
{
public:
    virtual ~Person() 
    {
        cout << "~Person()" << endl;
    }
};
class Student : public Person 
{
public:
	virtual ~Student() 
	{
		cout << "~Student()" << endl; 
	}
};
// 	只有派生类Student的析构函数重写了Person的析构函数，下面的delete对象调用析构函数，才能构成多
//	态，才能保证p1和p2指向的对象正确的调用析构函数。
int main()
{
    Person* p1 = new Person;
    Person* p2 = new Student;
    delete p1;
    delete p2;
    return 0;
}

~~~

* **接口继承和实现继承**

普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。虚函数的
继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果不实现多态，不要把函数定义成虚函数。

* **虚函数小结**
  (1)  在基类中用 `virual` 声明成员函数为虚函数。类外实现虚函数时，不必再加 `virtual`。
  (2)  在派生类中重新定义此函数称为覆写，要求函数名，返值类型，函数参数个数及类型全部匹配。并根据派生类的需要重新定义函数体。
  (3)  当一个成员函数被声明为虚函数后，其派生类中完全相同的函数（显示的写出）也为虚函数。 可以在其前加 `virtual`以示清晰。
  (4)  定义一个指基类对象的指针，并使其指向其子类的对象，通过该指针调用虚函数，此时调用的就是指针变量指向对象的同名函数。
  (5)  子类中的覆写的函数，可以为任意访问类型，依子类需求决定。

##### 1.4 、多态实现的前提（赋值兼容规则）

赋值兼容规则是指在需要基类对象的任何地方都可以使用公有派生类的对象来替代。赋值兼
容是一种默认行为，不需要任何的显示的转化步骤。
赋值兼容规则中所指的替代包括以下的情况：

 * 派生类的对象可以赋值给基类对象。
 * 派生类的对象可以初始化基类的引用。
 * 派生类对象的地址可以赋给指向基类的指针。

在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。

**补充：**父类也可以通过强转的方式转化为子类。 父类对象强转为子类对象后，访问从父类继承
下来的部分是可以的，但访问子类的部分，则会发生越界的风险，越界的结果是未知的。

##### 1.5、抽象类

在虚函数的后面写上` =0` ，则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类（也叫接口类），抽象类
不能实例化出对象。派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯
虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。

~~~C++
class Car
{
public:
	virtual void drive() = 0; //虚函数
};

class Benz : public Car
{
	virtual void drive()
	{
		cout << "舒适" << endl;
	}
};

class BWM : public Car
{
	virtual void drive()
	{
		cout << "BMW-操控" << endl;
	}

};
~~~

* **纯虚函数小结**

(1)  含有纯虚函数的类，称为抽象基类，不可实列化。即不能创建对象，存在的意义就是被继承，提供族类的公共接口，`Java` 中称为` interface`。

(2)  纯虚函数只有声明，没有实现，被“初始化”为 0。

(3)  如果一个类中声明了纯虚函数，而在派生类中没有对该函数定义，则该虚函数在派生类
中仍然为纯虚函数，派生类仍然为纯虚基类。

* **若干限制**

（1）只有类的成员函数才能声明为虚函数。虚函数仅适用于有继承关系的类对象，所以普通函数不能声明为虚函数。

（2)  静态成员函数不能是虚函数。静态成员函数不受对象的捆绑，只有类的信息。

（3)  内联函数不能是虚函数

（4)  构造函数不能是虚函数。构造时，对象的创建尚未完成。构造完成后，才能算一个名符其实的对象。

（5)  析构函数可以是虚函数且通常声明为虚函数。

##### 1.6、C++11的`overried`和`final`

在C++11中，提供`overried`和`final`来修饰虚函数。

`overried`用于修饰派生类的虚函数，表示强制完成重写。

`final`用于修饰基类的虚函数 ，表示不能被重写。

~~~C++
// 1.final 修饰基类的虚函数不能被派生类重写
class Car
{
public:
	virtual void drive()  {}
	virtual void look() final{} //不能被重写
};

// 2.override 修饰派生类虚函数强制完成重写，如果没有重写会编译报错
class Benz :public Car {
public:
	virtual void drive() override { cout << "Benz-舒适" << endl; } 
};
~~~

