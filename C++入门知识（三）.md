# C++入门知识（三）

## 一、auto关键字（C++11）

### 1、auto简介

在早期C/C++，`auto`被解释为一个自动存储变量的关键字，也就是申明一块临时的变量内存。自动变量意为拥有自动的生命期，这是多余的，因为就算不使用`auto`声明，变量依旧拥有自动的生命期。所以，早期的auto基本没人使用。

在C++11标准的语法中，`auto`重新被定义为自动推断变量的类型。auto声明的变量必须由编译器在编译时期推导而得。因此我们需要注意，使用auto定义变量时必须对其进行初始化。请看代码：

~~~c++
// auto关键字
int TestAuto()
{
    return 10;
}

int main()
{
    int a = 10;
    auto b = a;
    auto c = 'a';
    auto d = TestAudo();
    
    std::cout<<typied(b).name()<<endl;
    std::cout<<typied(c).name()<<endl;
    std::cout<<typied(d).name()<<endl;
    
    // auto e; //此语句无法编译通过，未初始化。
    return 0;
}
~~~

###2、auto使用细则

#### 2.1、auto与指针结合使用

用`auto`声明指针类型的时候，用`auto`和`autu*`没有任何区别，但是用auto声明引用类型是则必须加&。

~~~c++
int main()
{
	int x = 10;
	auto a = &x;
	auto *b = &x;
	auto &c = x;
	
	return 0;
}
~~~

####2.2、在同一行定义多个变量

当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。

~~~c++
void TestAuto()
{
    auto a = 1, b = 2;
    auto c = 3, d = 4.0; //该代码编译报错，因为c和d的初始化表达式类型不同
}
~~~

#### 2.3、auto不能推导的场景

* auto不能作为函数的参数

~~~c++
void TestAuto(auto a) //错误
{}
~~~

* auto不能直接用来声明数组

~~~c++
void TestAuto()
{
    int a[] = {1, 2, 3, 4};
    auto b[] = {5, 6, 7}; // 错误
}
~~~

* auto不能定义类的非静态成员变量
* 实例化模板时不能使用auto作为模板参数



## 二、基于范围的for循环（C++11）

###1、基本概念

C++11提供了一个特殊版本的 for 循环，在很多情况下，它都可以简化数组的处理，这就是基于范围的 for 循环。在使用基于范围的 for 循环处理数组时，该循环可以自动为数组中的每个元素迭代一次。

基于范围的 for 循环使用了一个称为范围变量的内置变量。每次基于范围的 for 循环迭代时，它都会复制下一个数组元素到范围变量。

以下是基于范围的 for 循环的一般格式：

~~~c++
 // 基于范围的for循环
for (dataType rangeVariable : array)
    statement;
~~~

现在来看一看该格式的各个部分：

- dataType：是范围变量的数据类型。它必须与数组元素的数据类型一样，或者是数组元素可以自动转换过来的类型。
- rangeVariable：是范围变量的名称。该变量将在循环迭代期间接收不同数组元素的值。在第一次循环迭代期间，它接收的是第一个元素的值；在第二次循环迭代期间，它接收的是第二个元素的值；以此类推。
- array：是要让该循环进行处理的数组的名称。该循环将对数组中的每个元素迭代一次。
- statement：是在每次循环迭代期间要执行的语句。要在循环中执行更多的语句，则可以使用一组大括号来包围多个语句。

我们看一个示例：

~~~c++
// 输出数组array中的元素
void test () 
{
    int array[] = {2, 5, 6, 4};
    // 基于范围的for循环
	for (int i: array)
        std::cout << i << std::endl;   
}
~~~

与普通循环类似，我们可以使用continue来结束本次循环，也可以用break来跳出整个循环。

### 2、使用条件

* for循环迭代的范围必须是确定的。对于数组而言，就是数组中的第一个元素和最后一个元素；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围。
* 迭代的对象要实现++和==的操作。

### 3、使用基于范围的for循环来修改数组

  当基于范围的 for 循环执行时，其范围变量将仅包含一个数组元素的副本。因此，不能使用基于范围的 for 循环来修改数组的内容，除非将范围变量声明为一个引用。引用变量是其他值的一个别名，任何对于引用变量的修改都将实际作用于别名所代表的值。

要将范围变量声明为引用变量，可以在循环头的范围变量名称前面添加一个 `&` 符号。下面程序即显示了这样一个示例，它使用了基于范围的 for 循环来将用户输入的数据存储到一个数组中。  

~~~c++
int main()
{
	const int SIZE = 5;
	int array[SIZE];
	//输出数值
	for (int &val : array)
	{
		std::cout << "请输入一个整数: ";
		std::cin >> val;
	}
	// Display the values in the array.
	std::cout << "\n你输入的值为: \n";
	for (int val : array)
		std::cout << val << " ";
	std::cout << std::endl;
	system("pause");
	return 0;
}
~~~

## 三、指针空值nullptr(C++11)

在C++98中，如果指针没有指向，我们会对指针进行初始化。如：

~~~
void testptr()
{
    int* p1 = NULL;
    int* p2 = 0; 
}
~~~

而在C++11中，给出了全新的`nullptr`，用来表示空指针。`nullptr`代表是一个指针空值常量，其类型为`nullptr_t`，仅仅可以被隐式转换为指针类型，`nullptr_t`被定义在头文件中。

注意：

* 在使用`nullptr`表示指针空值时，不需要包含头文件，因为`nullptr`是C++ 作为新关键字引入的。
* 在C++11中，`sizeof(nullptr)`与`sizeof(void*)0)`所占字节数相同
* 为了提高代码的健壮性，在后续表示指针空值时，最好使用`nullptr`。

