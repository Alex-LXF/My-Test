# C++入门知识（二）

## 一、内联函数

内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数的区别不在于编写方式，而在于C++编译器如何将它们整合到程序中。

通常程序执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到函数主体的内存单元块，执行函数代码。函数执行完后跳回到地址被保存的指令出，程序继续执行。这个过程就如同我们在浏览一篇古文，需要不断来回跳跃查看注解。

而内联函数刚好解决了此问题。使用内联函数后，函数主体代码将会替换函数的调用，此时就没有函数压栈的开销。

我们将以`inline`修饰的函数称为内联函数。

~~~c++
//常规函数
int _printf(int a)
{
	printf("%d ",a);
    return a;
}

int main()
{
    ···
	_printf(1);
    _printf(2);
    _printf(3);
    
    return 0;
}
~~~

~~~c++
//内联函数
inline int _printf(int a)
{
	printf("%d ",a);
    return a;
}

int main()
{
    ···
	_printf(1);
    _printf(2);
    _printf(3);
    
    return 0;
}
~~~

![1552718512309](C:\Users\LXF\AppData\Roaming\Typora\typora-user-images\1552718512309.png)

**内联函数的特点：**

（1）`inline`是一种以空间换时间的做法，省去调用函数额外开销。所以代码很长或者有循环/递归的函数不宜使用作为内联函数。

（2）`inline`对于编译器只是一种建议，如果定义`inline`的函数体内有循环或者递归等，编译器优化时会自动忽略内联。

（3）`inline`不建议声明和定义分离，分离会导致链接错误。

## 二、引用

### 1、引用的概念

引用是已定义变量的别名。

比如：李逵，在家被称为“铁牛”，江湖人称“黑旋风”。

现在让我们看一个例子：

~~~c++
void TestRef()
{
    int a = 10;
    int& pa = a; // 定义应用类型
    
    printf("%d",a);
    printf("%d",pa);
}
~~~

从上面我们可以看出：类型& 引用变量名(对象名) = 引用实体；

很显然，这里给&符号赋予了另个一个含义，将其用来声明引用。



### 2、引用的特性

1、引用在定义时必须初始化。

2、一个变量可以有多个引用；

3、引用一旦引用一个实体，再不能引用其他实体；

4、对引用求地址，就是对目标变量求地址。`&a = &pa`。

5、不能建立引用的数组。因为数组是一个由若干个元素所组成的集合，所以无法建立一个由引用组成的集合。但是可以建立数组的引用。

### 3、常引用

常引用声明方式：`const`  类型标识符& 引用名 = 目标变量名；

用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为`const`，达到了引用的安全性。

~~~c++
void test(){
    int a = 5;
    const int& pa = a;
    pa = 1; //错误
    a = 1; //正确
}
~~~

### 4、引用作用

* 做参数

~~~C++
//引用做参数
#include <iostream>
using namespace std;
 
// 函数声明
void swap(int& x, int& y);
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout << "交换前，a 的值：" << a << endl;
   cout << "交换前，b 的值：" << b << endl;
 
   /* 调用函数来交换值 */
   swap(a, b);
 
   cout << "交换后，a 的值：" << a << endl;
   cout << "交换后，b 的值：" << b << endl;
 
   return 0;
}
 
// 函数定义
void swap(int& x, int& y)
{
   int temp;
   temp = x; // 保存地址 x 的值 
   x = y;    // 把 y 赋值给 x 
   y = temp; // 把 x 赋值给 y  
}
~~~

C++新增的这项特性是对C语言的超越，C语言只能按值传递。我们用C语言的方式实现交换函数。

~~~c
//按值传参
void swap(int a, int b)
{
    int c = a;
    a = b;
    b = c;
}

~~~

我们都知道按值传递导致被调用函数使用调用程序的值的拷贝。在交换函数中，使用按值传递无法得到正确结果，所以在C语言中提出按指针传递的方式，避免了按值传递的限制。

~~~c
//按指针传递
void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
~~~



![1552726606135](C:\Users\LXF\AppData\Roaming\Typora\typora-user-images\1552726606135.png)

此图为按值传递和按引用传递的比较。

* 做返回值

通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。

以引用返回函数值，定义函数时需要在函数名前加 &

例如，请看下面这个简单的程序：

~~~c++
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues( int i )
{
  return vals[i];   // 返回第 i 个元素的引用
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
~~~

当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。

**引用作为返回值，必须遵守以下规则：**

（1）不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。

 （2）不能返回函数内部`new`分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况 （返回函数内部`new`分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由`new`分配）就无法释放，造成`memory leak`。

 （3）可以返回类成员的引用，但最好是`const`。主要原因是当对象的属性是与某种业务规则（`business rule`）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

### 5、引用与指针的区别

在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。在底层实现上实际是有空间的，因为引用是按照指针的方式来实现的。

**引用和指针的区别：**

（1）引用在定义时必须初始化，而指针没有要求。

（2）引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。

（3）没有NULL引用，但有NULL指针。

（4）在`sizeof`中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数。

（5）引用自加即引用实体自加1，指针自加即指针向后偏移一个类型的大小。

（6）有多级指针，但没有多级引用。

（7）访问实体方式不同，指针需要显示解引用，引用编译器自己处理。

（8）引用比指针使用起来更加安全。



参考：C++ Primer Plus  、菜鸟网络。

如有问题，欢迎指出。

