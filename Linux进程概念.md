## Linux进程概念

### 1. 基本概念

进程是正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。

进程是正在执行中的程序。当程序被执行时，执行人的权限和属性，以及程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 PID（进程 ID）。

在操作系统中，所有可以执行的程序与命令都会产生进程，只是有些程序和命令非常简单，如` ls` 命令、`touch` 命令等，它们在执行完后就会结束，相应的进程也就会终结，所以我们很难捕捉到这些进程。但是还有一些程和命令，比如` httpd `进程，启动之后就会一直驻留在系统当中，我们把这样的进程称作常驻内存进程。

### 2. 描述进程 - PCB

进程信息被放在一个叫做进程控制块`(process control block,PCB)`的数据结构中，可以理解为进程属性的集合。`Linux`操作系统下的 PCB 是:` task_struct`。

`task_struct`是`Linux`内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息。

**task_struct 下内容分类**：

> * 标示符: 描述本进程的唯一标示符，用来区别其他进程。
> * 状态: 任务状态，退出代码，退出信号等。
> * 优先级: 相对于其他进程的优先级。
> * 程序计数器: 程序中即将被执行的下一条指令的地址。
> * 内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
> * 上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。
> * I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
> * 记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
>   其他信息

### 3. 进程状态查看

**操作指令**：`ps`

**命令描述**：用来静态地查看系统中正在运行的进程的命令。

**部分选项**：

> * a：显示一个终端的所有进程，除会话引线外；
> * u：显示进程的归属用户及内存的使用情况；
> * x：显示没有控制终端的进程；
> * -l：长格式显示。显示更加详细的信息；
> * -e：显示所有进程；

说明：它的部分选项不能加入"-"，比如命令"ps aux"，其中"aux"是选项，但是这个选项不能加入"-"。这是因为 ps 命令的部分选项需要遵守 BSD 操作系统的格式。所以，ps 命令的常用选项的组合是固定的。

**常用操作**：

> * "`ps aux`"可以查看系统中所有的进程；
> * "`ps -le`"可以查看系统中所有的进程，而且还能看到进程的父进程的PID和进程优先级；
> * "`ps -l`"只能看到当前Shell产生的进程；



![ps](https://github.com/Alex-LXF/picture/blob/master/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/ps.png?raw=true)

### 4. 进程的状态

进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。

**进程的状态有以下几种：**

> * R 运行状态（runing）：并不意味着进程一定在运行中，也可以在运行队列里；
> * S 睡眠状态（sleeping）：进程在等待事件完成；（浅度睡眠，可以被唤醒）
> * D 磁盘睡眠状态（Disk sleep）:不可中断睡眠（深度睡眠，不可以被唤醒，通常在磁盘写入时发生）
> * T 停止状态（stopped）：可以通过发送SIGSTOP信号给进程来停止进程，可以发送SIGCONT信号让进程继续运行
> * X 死亡状态（dead）:该状态是返回状态，在任务列表中看不到；
> * Z 僵尸状态（zombie）:子进程退出，父进程还在运行，但是父进程没有读到子进程的退出状态，子进程进入僵尸状态；
> * t 追踪停止状态（trancing stop）

这里说一下僵尸状态。

**僵死状态**（Zombies）是一个比较特殊的状态。当进程退出并且父进程（使用wait()系统调用）
没有读取到子进程退出的返回代码时就会产生僵死(尸)进程。僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入 Z 状态。

**僵尸进程的危害：**

1. Z 状态不退出，**PCB需要一直对其维护**；
2. **浪费内存资源**。如果僵尸进程一直没有退出，就会一直占用这块内存，就会导致内存资源的浪费；
3. **内存泄漏**。僵尸进程一直占用资源，但是却不使用，就可能会导致内存泄漏。

**父子进程：**

利用`fork()`函数从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。具体内容，下一篇博文进行讲解。

**孤儿进程：**

孤儿进程是指：父进程先退出，子进程变为“孤儿进程”。

父进程先退出，子进程后退出，由于父进程已经退出读取不到子进程的退出信息，子进程变为 Z（僵尸）状态，随后子进程被1号进程 `init`  “领养”。

